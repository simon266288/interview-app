<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>前端面试刷题助手 - 梅军军专属版</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Vue 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        /* 自定义样式补充 */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f3f4f6; /* gray-100 */
            -webkit-tap-highlight-color: transparent;
        }
        
        /* 隐藏滚动条但保留功能 */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        /* 卡片翻转效果 */
        .flip-card {
            perspective: 1000px;
        }
        .flip-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }
        .flip-card.flipped .flip-card-inner {
            transform: rotateY(180deg);
        }
        .flip-card-front, .flip-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            border-radius: 1rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 1.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .flip-card-front {
            background-color: white;
            color: #1f2937;
        }
        .flip-card-back {
            background-color: #eff6ff; /* blue-50 */
            color: #1f2937;
            transform: rotateY(180deg);
        }

        /* 选项震动动画 */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-4px); }
            20%, 40%, 60%, 80% { transform: translateX(4px); }
        }
        .shake-animation {
            animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both;
        }
    </style>
</head>
<body class="text-gray-800 h-screen overflow-hidden flex flex-col">
    <div id="app" class="h-full flex flex-col max-w-md mx-auto bg-white shadow-xl w-full relative overflow-hidden">
        <!-- 动态视图容器 -->
        <component :is="currentViewComponent"></component>
    </div>

    <script>
        const { createApp, reactive, computed, ref, onMounted, watch } = Vue;

        // --- 1. 数据模型与题库 (Question Bank) ---
        // 实际开发中，这些数据通常来自 JSON 文件或 API，这里直接硬编码以满足单文件需求
        const MODULES = [
            "JS/CSS 基础", "Vue 核心原理", "性能优化", "工程化 (Webpack/Vite)", 
            "低代码平台", "浏览器与网络", "手写代码", "场景题 & 项目经验"
        ];

        // 占位题库，后续将填充完整 80+ 道题
        const QUESTION_BANK = [
            // --- 模块 1：JS/CSS 基础 ---
            { id: 101, type: "choice", module: "JS/CSS 基础", question: "下列关于闭包的说法，错误的是？", options: ["闭包可以访问外部函数的变量", "闭包会造成内存泄漏，应禁止使用", "闭包可以实现数据私有化", "函数嵌套函数且内部函数引用外部变量即形成闭包"], answer: 1, analysis: "闭包虽然可能导致内存占用增加，但并非一定造成内存泄漏（除非循环引用或未释放）。它是 JS 核心特性，广泛用于模块化、防抖节流等场景，不应禁止使用。" },
            { id: 102, type: "choice", module: "JS/CSS 基础", question: "Flex 布局中，实现主轴居中对齐的属性是？", options: ["align-items: center", "justify-content: center", "align-content: center", "text-align: center"], answer: 1, analysis: "justify-content 控制主轴（横向）对齐，align-items 控制交叉轴（纵向）对齐。" },
            { id: 103, type: "choice", module: "JS/CSS 基础", question: "Promise.all([p1, p2]) 中，如果 p1 失败（rejected），结果会怎样？", options: ["等待 p2 完成后返回结果", "立刻返回 rejected 状态和 p1 的错误", "返回 p2 的成功结果", "抛出异常终止程序"], answer: 1, analysis: "Promise.all 具有'一损俱损'特性，只要有一个 rejected，整体立即 rejected。如果需要全部执行完，应使用 Promise.allSettled。" },
            { id: 104, type: "choice", module: "JS/CSS 基础", question: "下列哪个操作不会触发重排（Reflow）？", options: ["修改元素宽度 width", "修改元素颜色 color", "修改元素位置 top", "修改浏览器窗口大小"], answer: 1, analysis: "修改颜色（color/background）只触发重绘（Repaint），不改变布局几何信息，因此不触发重排。其他选项都会改变几何布局。" },
            { id: 105, type: "choice", module: "JS/CSS 基础", question: "ES6 中，箭头函数与普通函数的区别，描述错误的是？", options: ["箭头函数没有自己的 this", "箭头函数不能作为构造函数", "箭头函数没有 arguments 对象", "箭头函数可以改变 prototype 指向"], answer: 3, analysis: "箭头函数没有 prototype 属性，因此不能作为构造函数，也不能改变 prototype。" },
            { id: 106, type: "judge", module: "JS/CSS 基础", question: "CSS 中 BFC（块级格式化上下文）区域内的元素与外部元素相互隔离，互不影响。", answer: true, analysis: "正确。BFC 是一个独立的渲染区域，内部布局不会影响外部，常用于清除浮动、防止 margin 重叠。" },
            { id: 107, type: "judge", module: "JS/CSS 基础", question: "0.1 + 0.2 === 0.3 的结果是 true。", answer: false, analysis: "错误。由于 IEEE 754 浮点数精度问题，0.1 + 0.2 结果是 0.30000000000000004。" },
            { id: 108, type: "choice", module: "JS/CSS 基础", question: "以下哪个事件循环（Event Loop）阶段执行微任务（Microtask）？", options: ["setTimeout 回调之后", "宏任务执行结束，渲染之前", "DOM 渲染之后", "setInterval 回调之中"], answer: 1, analysis: "微任务（Promise.then, nextTick）在当前宏任务结束后、UI 渲染前清空。" },
            { id: 109, type: "choice", module: "JS/CSS 基础", question: "HTTP 状态码 304 代表什么？", options: ["永久重定向", "未授权", "资源未修改（使用缓存）", "服务器内部错误"], answer: 2, analysis: "304 Not Modified 表示资源未修改，客户端可直接使用本地缓存，通过 ETag/Last-Modified 协商。" },
            { id: 110, type: "choice", module: "JS/CSS 基础", question: "CommonJS 和 ES Module 的核心区别是？", options: ["CommonJS 是静态加载，ESM 是动态加载", "CommonJS 输出值的拷贝，ESM 输出值的引用", "CommonJS 只能用于浏览器", "ESM 不支持 Tree Shaking"], answer: 1, analysis: "CommonJS 运行时加载且输出拷贝；ESM 编译时输出接口（引用），支持静态分析（Tree Shaking）。" },

            // --- 模块 2：Vue 核心原理 ---
            { id: 201, type: "choice", module: "Vue 核心原理", question: "Vue3 的响应式系统使用什么 API 代替了 Vue2 的 Object.defineProperty？", options: ["Object.observe", "Proxy", "Reflect.defineProperty", "Symbol"], answer: 1, analysis: "Vue3 使用 Proxy 代理对象，可拦截所有操作（增删属性、数组下标），性能优于 Vue2 的递归劫持。" },
            { id: 202, type: "choice", module: "Vue 核心原理", question: "Vue2 中修改数组下标无法触发视图更新，常用的解决办法是？", options: ["this.$set / Vue.set", "Object.assign", "Array.prototype.push", "强制刷新"], answer: 0, analysis: "Vue2 无法检测索引赋值，需用 Vue.set(arr, index, val) 或 splice 触发响应式更新。" },
            { id: 203, type: "choice", module: "Vue 核心原理", question: "关于 Vue3 Composition API 的 setup() 函数，说法错误的是？", options: ["执行时机在 beforeCreate 之前", "内部无法访问 this", "可以直接返回渲染函数", "可以访问 data 和 methods 中定义的变量"], answer: 3, analysis: "setup() 执行非常早（beforeCreate 之前），此时 Options API 的 data/methods 尚未初始化，因此无法访问。" },
            { id: 204, type: "choice", module: "Vue 核心原理", question: "Vue Diff 算法中，key 的作用是？", options: ["优化 v-if 切换性能", "唯一标识节点，复用 DOM 提高 Diff 效率", "防止样式冲突", "给 CSS 动画提供标识"], answer: 1, analysis: "key 给 VNode 提供唯一标识，Diff 对比时能准确判断节点是移动还是销毁重建，最大化复用 DOM。" },
            { id: 205, type: "choice", module: "Vue 核心原理", question: "nextTick 的原理是？", options: ["setTimeout(0)", "Promise.resolve().then()", "MutationObserver", "以上都是（降级策略）"], answer: 3, analysis: "Vue 优先使用 Promise.then（微任务），不支持则降级为 MutationObserver、setImmediate、setTimeout。" },
            { id: 206, type: "judge", module: "Vue 核心原理", question: "Vue3 中使用 ref 定义基本类型，reactive 定义对象类型，这是强制规定的。", answer: false, analysis: "错误。ref 也可以定义对象（内部自动转 reactive），reactive 只能定义对象。通常建议统一用 ref 以保持一致性（自动解包）。" },
            { id: 207, type: "judge", module: "Vue 核心原理", question: "keep-alive 组件的作用是缓存不活动的组件实例，避免反复销毁重建。", answer: true, analysis: "正确。keep-alive 配合 include/exclude 可缓存路由组件，保留状态（如滚动位置、表单内容）。" },
            { id: 208, type: "choice", module: "Vue 核心原理", question: "Vue 组件通信中，子组件修改父组件数据的正确方式是？", options: ["直接修改 props", "通过 $parent 修改", "emit 事件通知父组件修改", "使用全局变量"], answer: 2, analysis: "单向数据流原则，Props 只读。子组件应 $emit('update:xxx', val) 通知父组件修改。" },
            { id: 209, type: "choice", module: "Vue 核心原理", question: "Pinia 相比 Vuex 的改进，不包括？", options: ["移除了 Mutation", "更好的 TypeScript 支持", "支持多 Store 拆分", "增加了 Module 嵌套结构"], answer: 3, analysis: "Pinia 恰恰去掉了复杂的 Module 嵌套，改为扁平化的多 Store 模式，且移除了冗余的 Mutation。" },
            { id: 210, type: "choice", module: "Vue 核心原理", question: "Vue3 的 Teleport 组件主要用于？", options: ["路由跳转", "数据传输", "将组件 DOM 渲染到 body 等指定节点", "动画效果"], answer: 2, analysis: "Teleport（传送门）允许将模态框、Tooltip 等 DOM 渲染到 DOM 树之外（如 body），解决 z-index 层级问题。" },

            // --- 模块 3：性能优化 ---
            { id: 301, type: "choice", module: "性能优化", question: "对于长列表（如 10 万条数据），最有效的性能优化手段是？", options: ["分页加载", "虚拟列表（Virtual List）", "懒加载", "服务端渲染"], answer: 1, analysis: "虚拟列表只渲染可视区域 DOM，无论数据多少，DOM 节点数恒定，彻底解决卡顿。分页和懒加载仍可能导致 DOM 过多。" },
            { id: 302, type: "choice", module: "性能优化", question: "图片懒加载（Lazy Load）的核心原理是？", options: ["使用 setTimeout 延时加载", "监听 scroll 事件或使用 IntersectionObserver", "压缩图片体积", "使用 SVG 占位"], answer: 1, analysis: "通过监听元素是否进入视口（IntersectionObserver API 性能最好），再将 data-src 赋值给 src。" },
            { id: 303, type: "choice", module: "性能优化", question: "Webpack 中开启 Gzip 压缩需要配置哪个插件？", options: ["HtmlWebpackPlugin", "MiniCssExtractPlugin", "CompressionWebpackPlugin", "DefinePlugin"], answer: 2, analysis: "CompressionWebpackPlugin 用于构建时生成 .gz 文件，Nginx 开启 gzip_static 后直接传输，减少 CPU 压力。" },
            { id: 304, type: "judge", module: "性能优化", question: "CDN（内容分发网络）不仅能加速静态资源加载，还能解决跨域问题。", answer: false, analysis: "错误。CDN 主要通过就近节点加速资源获取。跨域问题仍需配置 CORS 或 Nginx 反代，CDN 本身不解决跨域（除非配置 Access-Control-Allow-Origin）。" },
            { id: 305, type: "choice", module: "性能优化", question: "为了减少首屏白屏时间（FCP），以下做法无效的是？", options: ["路由懒加载", "SSR 服务端渲染", "骨架屏（Skeleton）", "将所有 JS 打包成一个文件"], answer: 3, analysis: "打包成一个大文件会导致下载解析时间过长，加剧白屏。应拆包（Code Splitting）并按需加载。" },
            { id: 306, type: "choice", module: "性能优化", question: "浏览器缓存策略中，优先级最高的是？", options: ["Strong Cache (Expires/Cache-Control)", "Negotiation Cache (ETag)", "Service Worker", "Memory Cache"], answer: 2, analysis: "Service Worker 拦截请求优先级最高，可完全控制缓存逻辑（PWA 核心）。" },
            { id: 307, type: "choice", module: "性能优化", question: "防抖（Debounce）和节流（Throttle）的区别？", options: ["防抖是多次触发只执行最后一次，节流是规定时间内只执行一次", "防抖适合滚动事件，节流适合搜索框", "两者完全一样", "防抖立即执行，节流延迟执行"], answer: 0, analysis: "防抖：最后一次触发后等待 N 秒执行（适合搜索联想）；节流：每隔 N 秒执行一次（适合 resize/scroll）。" },
            { id: 308, type: "judge", module: "性能优化", question: "使用 WebP 格式图片通常比 PNG/JPG 体积更小，但需注意兼容性。", answer: true, analysis: "正确。WebP 压缩率高，但旧版 Safari/IE 不支持，需 <picture> 标签做降级处理。" },
            { id: 309, type: "choice", module: "性能优化", question: "排查内存泄漏（Memory Leak）通常使用 Chrome DevTools 的哪个面板？", options: ["Network", "Performance", "Memory", "Lighthouse"], answer: 2, analysis: "Memory 面板可录制堆快照（Heap Snapshot），对比分离 DOM 和 JS 对象引用。" },
            { id: 310, type: "choice", module: "性能优化", question: "大文件上传（1GB+）优化的核心技术方案是？", options: ["压缩文件", "Base64 编码", "切片上传 + 断点续传", "WebSocket 传输"], answer: 2, analysis: "将文件切分为小块（Chunk）并发上传，失败仅重传该块；服务端合并。Base64 会增加体积，不适合大文件。" },

            // --- 模块 4：工程化 (Webpack/Vite) ---
            { id: 401, type: "choice", module: "工程化 (Webpack/Vite)", question: "Webpack 中 Loader 和 Plugin 的区别？", options: ["Loader 转换文件，Plugin 扩展功能", "Loader 处理 JS，Plugin 处理 CSS", "Loader 运行在打包后，Plugin 运行在打包前", "没有区别"], answer: 0, analysis: "Loader（转换器）将非 JS 文件（Less/Vue）转为 JS；Plugin（插件）监听生命周期钩子，执行复杂任务（压缩、拷贝、注入）。" },
            { id: 402, type: "choice", module: "工程化 (Webpack/Vite)", question: "Vite 相比 Webpack 开发环境启动快的主要原因是？", options: ["使用 Rust 编写", "基于 ESM 原生模块加载，不打包", "缓存机制更好", "多线程编译"], answer: 1, analysis: "Vite 开发模式下利用浏览器原生 ES Module 支持，直接请求源码，省去了 Webpack 漫长的 bundle 过程。" },
            { id: 403, type: "choice", module: "工程化 (Webpack/Vite)", question: "Webpack 的 Tree Shaking 依赖于什么模块规范？", options: ["CommonJS", "AMD", "ES Module (ES6)", "UMD"], answer: 2, analysis: "Tree Shaking 依赖 ESM 的静态结构分析，CommonJS 是动态的，无法确定哪些导出未被使用。" },
            { id: 404, type: "choice", module: "工程化 (Webpack/Vite)", question: "Babel 的主要作用是？", options: ["代码压缩", "ES6+ 转 ES5 语法降级", "CSS 预处理", "代码风格检查"], answer: 1, analysis: "Babel 是 JS 编译器，将新语法转为旧浏览器兼容的 ES5 代码。" },
            { id: 405, type: "choice", module: "工程化 (Webpack/Vite)", question: "Git 命令中，将暂存区内容提交到本地仓库的是？", options: ["git add", "git commit", "git push", "git checkout"], answer: 1, analysis: "add 到暂存区，commit 到本地库，push 到远程库。" },
            { id: 406, type: "choice", module: "工程化 (Webpack/Vite)", question: "Webpack 配置中 resolve.alias 的作用是？", options: ["定义全局变量", "配置路径别名（如 @ 指向 src）", "解析 CSS 文件", "压缩代码"], answer: 1, analysis: "方便引入文件，避免 ../../../ 这种长路径。" },
            { id: 407, type: "choice", module: "工程化 (Webpack/Vite)", question: "Git Flow 工作流中，feature 分支通常从哪个分支检出？", options: ["master", "develop", "release", "hotfix"], answer: 1, analysis: "feature（功能分支）从 develop 检出，完成后合并回 develop。" },
            { id: 408, type: "judge", module: "工程化 (Webpack/Vite)", question: "Vite 生产环境打包默认使用 Rollup，而不是 esbuild。", answer: true, analysis: "正确。虽然 esbuild 极快（用于开发环境预构建），但 Rollup 在代码分割和 CSS 处理上更成熟，因此 Vite 生产环境目前仍用 Rollup。" },
            { id: 409, type: "choice", module: "工程化 (Webpack/Vite)", question: "npm scripts 中串行执行两个命令的连接符是？", options: ["&", "&&", "||", "|"], answer: 1, analysis: "&& 是串行（前一个成功才执行后一个），& 是并行（同时执行）。" },
            { id: 410, type: "choice", module: "工程化 (Webpack/Vite)", question: "Monorepo（单体仓库）架构的优势不包括？", options: ["统一工作流和依赖管理", "代码共享方便", "构建速度绝对变快", "原子化提交"], answer: 2, analysis: "Monorepo 随着项目增多，全量构建速度会变慢，通常需要 Turborepo 等工具进行增量构建优化。" },

            // --- 模块 5：低代码平台 (项目相关) ---
            { id: 501, type: "choice", module: "低代码平台", question: "低代码平台的核心驱动模式通常是？", options: ["MVC 模式", "MVVM 模式", "Schema（JSON）驱动", "直接生成 HTML"], answer: 2, analysis: "低代码核心是将页面结构、组件配置抽象为 JSON Schema，渲染器（Renderer）读取 Schema 动态渲染页面。" },
            { id: 502, type: "choice", module: "低代码平台", question: "在低代码编辑器中，实现组件从左侧物料区拖拽到画布，常用 HTML5 API 是？", options: ["Draggable / Dragstart / Drop", "TouchStart / TouchMove", "Click / Hover", "Canvas API"], answer: 0, analysis: "HTML5 Drag and Drop API 是实现 PC 端拖拽的标准方案。" },
            { id: 503, type: "choice", module: "低代码平台", question: "Monaco Editor（VS Code 内核）在低代码平台中的主要用途是？", options: ["渲染页面", "编写自定义 JS/CSS 代码", "文件上传", "绘制图表"], answer: 1, analysis: "Monaco Editor 提供专业的代码编辑体验（高亮、补全），常用于低代码平台的“高级设置”或“自定义逻辑”编写。" },
            { id: 504, type: "choice", module: "低代码平台", question: "低代码组件库版本管理中，为了防止组件更新导致旧页面崩溃，应采取什么策略？", options: ["强制所有页面更新", "组件版本化 + 语义化版本控制", "不更新组件", "手动修改数据库"], answer: 1, analysis: "Schema 中应记录组件版本号（如 Button@1.0.0），渲染时加载对应版本，确保旧页面不受新版组件 Breaking Change 影响。" },
            { id: 505, type: "judge", module: "低代码平台", question: "低代码平台的'出码'（Code Generation）是指将 JSON Schema 转换为可维护的 Vue/React 源码。", answer: true, analysis: "正确。除了运行时渲染，出码能力允许开发者导出源码进行二次开发，避免厂商锁定。" },
            { id: 506, type: "choice", module: "低代码平台", question: "在你的项目中，BlockSuite 方案主要解决了什么问题？", options: ["代码压缩", "通用组件库的构建与复用", "网络请求", "数据库设计"], answer: 1, analysis: "简历提到“引入 blocksuite 方案构建通用组件库”，旨在解决不同项目间 UI 模块的标准化复用。" },
            { id: 507, type: "choice", module: "低代码平台", question: "vue-json-pretty 库在低代码平台中通常用于？", options: ["美化代码", "展示和编辑 JSON Schema 数据", "图表渲染", "富文本编辑"], answer: 1, analysis: "简历提到“封装物料协议数据预览与编辑功能”，即用于直观展示组件配置的 JSON 结构。" },
            { id: 508, type: "choice", module: "低代码平台", question: "为了实现低代码平台的撤销/重做（Undo/Redo）功能，常用的设计模式是？", options: ["命令模式（Command Pattern）", "观察者模式", "单例模式", "工厂模式"], answer: 0, analysis: "命令模式将操作封装为对象，记录操作历史栈，方便执行 execute 和 undo。" },
            { id: 509, type: "judge", module: "低代码平台", question: "Schema 渲染器只需解析组件类型，不需要处理组件间的交互逻辑（如 A 组件改变触发 B 组件显隐）。", answer: false, analysis: "错误。高级低代码平台必须支持联动逻辑，通常在 Schema 中定义 events/actions 或表达式，渲染器需解析并执行这些逻辑。" },
            { id: 510, type: "choice", module: "低代码平台", question: "自定义 Webpack Plugin 实现源码脱敏，应该在哪个生命周期钩子介入？", options: ["entryOption", "compilation", "emit (资源输出前)", "done"], answer: 2, analysis: "emit 阶段可以获取到最终即将输出的 assets（代码文件），此时修改内容（脱敏）最为合适。" },

            // --- 模块 6：浏览器与网络 ---
            { id: 601, type: "choice", module: "浏览器与网络", question: "跨域（CORS）请求中，浏览器会自动发出预检请求（Preflight），其 HTTP 方法是？", options: ["POST", "GET", "OPTIONS", "HEAD"], answer: 2, analysis: "复杂请求（如带自定义头、非简单 Content-Type）会先发 OPTIONS 请求询问服务器是否允许跨域。" },
            { id: 602, type: "choice", module: "浏览器与网络", question: "TCP 三次握手的主要目的是？", options: ["加密传输", "建立可靠连接，同步序列号", "压缩数据", "分配 IP 地址"], answer: 1, analysis: "三次握手确认双方收发能力正常，同步初始序列号（ISN），建立可靠连接。" },
            { id: 603, type: "choice", module: "浏览器与网络", question: "浏览器输入 URL 到页面展示，解析 HTML 构建 DOM 树的阶段称为？", options: ["Parsing", "Layout", "Paint", "Composite"], answer: 0, analysis: "Parsing（解析）阶段将 HTML 文本转为 DOM 树。" },
            { id: 604, type: "choice", module: "浏览器与网络", question: "HTTPS 相比 HTTP 安全的原因是引入了什么协议？", options: ["SSH", "SSL/TLS", "FTP", "WebSocket"], answer: 1, analysis: "SSL/TLS 协议位于 TCP 和 HTTP 之间，提供加密、身份认证和完整性校验。" },
            { id: 605, type: "choice", module: "浏览器与网络", question: "XSS（跨站脚本攻击）的主要防范措施是？", options: ["使用 HTTPS", "对用户输入进行转义/过滤", "验证码", "Referer 检查"], answer: 1, analysis: "XSS 本质是恶意代码注入，核心防御是对输入输出进行 HTML 转义（Escaping）。" },
            { id: 606, type: "judge", module: "浏览器与网络", question: "LocalStorage 的数据会自动随 HTTP 请求发送给服务器。", answer: false, analysis: "错误。Cookie 会随请求发送，LocalStorage 和 SessionStorage 纯本地存储，除非手动读取发送。" },
            { id: 607, type: "choice", module: "浏览器与网络", question: "CSRF（跨站请求伪造）的防御手段不包括？", options: ["CSRF Token", "SameSite Cookie 属性", "验证 Referer", "使用 eval 函数"], answer: 3, analysis: "eval 是危险函数，容易导致 XSS，与防御 CSRF 无关。CSRF 防御核心是校验请求来源合法性。" },
            { id: 608, type: "choice", module: "浏览器与网络", question: "HTTP/2 相比 HTTP/1.1 的巨大改进是？", options: ["多路复用（Multiplexing）", "更复杂的 Header", "取消了状态码", "只支持文本"], answer: 0, analysis: "多路复用允许在单一 TCP 连接上并发传输多个请求/响应，解决了队头阻塞问题。" },
            { id: 609, type: "choice", module: "浏览器与网络", question: "以下哪个属性会导致回流（Reflow）？", options: ["transform: translate()", "opacity", "offsetWidth", "color"], answer: 2, analysis: "读取 offsetWidth/offsetHeight 会强制浏览器计算布局（Reflow），而 transform/opacity 仅触发合成（Composite），性能最好。" },
            { id: 610, type: "choice", module: "浏览器与网络", question: "WebSocket 是基于什么协议的？", options: ["UDP", "TCP", "HTTP", "FTP"], answer: 1, analysis: "WebSocket 基于 TCP，握手阶段使用 HTTP Upgrade 协议。" },

            // --- 模块 7：手写代码 (记忆卡片) ---
            { id: 701, type: "card", module: "手写代码", question: "手写防抖函数 (debounce)", answer: "function debounce(fn, delay) {\n  let timer = null;\n  return function(...args) {\n    if(timer) clearTimeout(timer);\n    timer = setTimeout(() => {\n      fn.apply(this, args);\n    }, delay);\n  }\n}" },
            { id: 702, type: "card", module: "手写代码", question: "手写节流函数 (throttle)", answer: "function throttle(fn, delay) {\n  let lastTime = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (now - lastTime > delay) {\n      fn.apply(this, args);\n      lastTime = now;\n    }\n  }\n}" },
            { id: 703, type: "card", module: "手写代码", question: "手写深拷贝 (Deep Clone)", answer: "function deepClone(obj) {\n  if (typeof obj !== 'object' || obj === null) return obj;\n  const result = Array.isArray(obj) ? [] : {};\n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      result[key] = deepClone(obj[key]);\n    }\n  }\n  return result;\n}\n// 注意：生产环境推荐 structuredClone 或 lodash.cloneDeep" },
            { id: 704, type: "card", module: "手写代码", question: "手写 Promise.all", answer: "Promise.myAll = function(promises) {\n  return new Promise((resolve, reject) => {\n    let count = 0;\n    let result = [];\n    const len = promises.length;\n    if(len === 0) resolve([]);\n    promises.forEach((p, i) => {\n      Promise.resolve(p).then(res => {\n        result[i] = res;\n        count++;\n        if (count === len) resolve(result);\n      }).catch(reject);\n    });\n  });\n}" },
            { id: 705, type: "card", module: "手写代码", question: "实现数组扁平化 (flat)", answer: "function flatten(arr) {\n  return arr.reduce((prev, cur) => {\n    return prev.concat(Array.isArray(cur) ? flatten(cur) : cur);\n  }, []);\n}\n// ES6: arr.flat(Infinity)" },
            { id: 706, type: "card", module: "手写代码", question: "手写 instanceof 原理", answer: "function myInstanceof(left, right) {\n  let proto = Object.getPrototypeOf(left);\n  while (true) {\n    if (proto === null) return false;\n    if (proto === right.prototype) return true;\n    proto = Object.getPrototypeOf(proto);\n  }\n}" },
            { id: 707, type: "card", module: "手写代码", question: "手写发布订阅模式 (EventEmitter)", answer: "class EventEmitter {\n  constructor() { this.events = {}; }\n  on(type, cb) {\n    if (!this.events[type]) this.events[type] = [];\n    this.events[type].push(cb);\n  }\n  emit(type, ...args) {\n    if (this.events[type]) {\n      this.events[type].forEach(cb => cb(...args));\n    }\n  }\n  off(type, cb) {\n    if (this.events[type]) {\n      this.events[type] = this.events[type].filter(x => x !== cb);\n    }\n  }\n}" },
            { id: 708, type: "card", module: "手写代码", question: "手写 new 操作符", answer: "function myNew(Constructor, ...args) {\n  const obj = Object.create(Constructor.prototype);\n  const result = Constructor.apply(obj, args);\n  return (typeof result === 'object' && result !== null) ? result : obj;\n}" },
            { id: 709, type: "card", module: "手写代码", question: "手写柯里化 (Currying)", answer: "function curry(fn) {\n  return function curried(...args) {\n    if (args.length >= fn.length) {\n      return fn.apply(this, args);\n    } else {\n      return function(...args2) {\n        return curried.apply(this, args.concat(args2));\n      }\n    }\n  }\n}" },
            { id: 710, type: "card", module: "手写代码", question: "手写 AJAX (XMLHttpRequest)", answer: "const xhr = new XMLHttpRequest();\nxhr.open('GET', url, true);\nxhr.onreadystatechange = function() {\n  if (xhr.readyState === 4 && xhr.status === 200) {\n    console.log(xhr.responseText);\n  }\n};\nxhr.send();" },

            // --- 模块 8：场景题 & 项目经验 ---
            { id: 801, type: "card", module: "场景题 & 项目经验", question: "低代码编辑器架构是如何设计的？", answer: "1. 协议层：定义 JSON Schema 描述页面结构。\n2. 渲染层：Renderer 组件递归解析 Schema，映射为 Vue 组件。\n3. 编辑器层：画布（拖拽区）、属性面板（Setter）、组件物料堆。\n4. 状态管理：使用 Vuex/Pinia 管理页面 Schema，实现 Undo/Redo。" },
            { id: 802, type: "card", module: "场景题 & 项目经验", question: "如何实现大文件切片上传？", answer: "1. 使用 File.slice() 将文件切割为固定大小的 Chunk。\n2. 计算文件 Hash（SparkMD5）作为唯一标识，实现秒传。\n3. 并发上传 Chunk（限制并发数，如 p-limit）。\n4. 所有 Chunk 上传成功后，发送 merge 请求通知后端合并。" },
            { id: 803, type: "card", module: "场景题 & 项目经验", question: "Webpack 打包体积减少 40% 具体做了哪些优化？", answer: "1. 开启 Gzip (CompressionWebpackPlugin)。\n2. 代码分割 (SplitChunks)：分离 node_modules 和业务代码。\n3. Tree Shaking：确保使用 ESM，package.json 配置 sideEffects。\n4.  externals：CDN 引入 Vue/ElementUI。\n5. 图片压缩 (image-webpack-loader)。" },
            { id: 804, type: "card", module: "场景题 & 项目经验", question: "虚拟列表在滚动时是如何计算的？", answer: "1. 监听 scroll 事件，获取 scrollTop。\n2. 计算 startIndex = Math.floor(scrollTop / itemHeight)。\n3. 计算 endIndex = startIndex + visibleCount。\n4. 截取 list.slice(startIndex, endIndex) 渲染。\n5. 设置 padding-top = startIndex * itemHeight 撑开容器位置。" },
            { id: 805, type: "card", module: "场景题 & 项目经验", question: "你们的组件库是如何设计和维护的？", answer: "1. Monorepo 架构（pnpm workspace）管理多包。\n2. 目录结构：packages/components, packages/theme 等。\n3. 打包：使用 Vite/Rollup 打包 ESM/UMD 格式。\n4. 文档：使用 VitePress 生成文档。\n5. 规范：ESLint + Prettier + CommitLint。" },
            { id: 806, type: "card", module: "场景题 & 项目经验", question: "移动端 1px 边框问题怎么解决？", answer: "1. 使用伪元素 + transform: scale(0.5)。\n2. 设置 viewport initial-scale=0.5。\n3. 使用 border-image。\n推荐方案：伪元素缩放，兼容性最好。" },
            { id: 807, type: "card", module: "场景题 & 项目经验", question: "如何处理前端权限控制（路由/按钮）？", answer: "1. 路由权限：后端返回权限表，addRoute 动态添加路由。\n2. 按钮权限：自定义指令 v-permission，判断无权限则 removeChild。\n3. 接口权限：Axios 拦截器处理 403 状态码。" },
            { id: 808, type: "card", module: "场景题 & 项目经验", question: "如何排查线上页面卡顿问题？", answer: "1. 使用 Chrome Performance 面板录制，分析 Long Task。\n2. 检查是否有频繁重排/重绘。\n3. 检查 JS 是否有死循环或复杂计算（考虑 Web Worker）。\n4. 检查内存泄漏。" },
            { id: 809, type: "card", module: "场景题 & 项目经验", question: "单点登录 (SSO) 的原理？", answer: "1. 用户访问系统 A，重定向到 CAS 认证中心。\n2. 认证中心登录成功，生成 Ticket，跳回系统 A。\n3. 系统 A 后端校验 Ticket，生成 Session。\n4. 访问系统 B 时，带上认证中心的 Cookie，自动完成认证。" },
            { id: 810, type: "card", module: "场景题 & 项目经验", question: "如何设计一个前端监控系统？", answer: "1. 数据采集：报错（window.onerror, unhandledrejection）、性能（Performance API）、行为（点击路径）。\n2. 数据上报：navigator.sendBeacon 或 Image Ping。\n3. 清洗与存储：后端处理。\n4. 可视化：Grafana 展示 PV/UV/JS报错率。" }
        ];

        // --- 2. 状态管理 (Store) ---
        const store = reactive({
            // 视图状态
            view: 'home', // home, modules, quiz, result, card, favorites, errors, exam, exam_result
            selectedModule: '',
            
            // 答题状态
            currentQuestions: [], // 当前练习的题目列表
            currentIndex: 0,
            userAnswers: {}, // { questionId: answer }
            examMode: false, // 是否为模拟考试
            examTimeLeft: 0, // 剩余秒数
            
            // 用户持久化数据
            progress: {
                completedIds: [], // 已完成题目ID (答对或记住了)
                wrongIds: [], // 错题ID (答错或没记住)
                favoriteIds: [], // 收藏题目ID
                moduleStats: {}, // 各模块进度 { 'Vue': 5 }
                examHistory: [] // 模拟考试记录
            }
        });

        // --- 3. 持久化逻辑 (Persistence) ---
        const STORAGE_KEY = 'interview_app_v1';
        
        const saveProgress = () => {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(store.progress));
        };

        const loadProgress = () => {
            const data = localStorage.getItem(STORAGE_KEY);
            if (data) {
                try {
                    const parsed = JSON.parse(data);
                    // 合并数据，防止新字段丢失
                    store.progress = { ...store.progress, ...parsed };
                } catch (e) {
                    console.error('Load progress failed', e);
                }
            }
        };

        // --- 4. 核心组件 (Components) ---
        
        // 4.1 首页组件
        const HomeView = {
            template: `
                <div class="h-full flex flex-col bg-gray-50">
                    <div class="p-6 bg-blue-600 text-white rounded-b-3xl shadow-lg">
                        <h1 class="text-2xl font-bold mb-2">前端面试助手</h1>
                        <p class="opacity-90 text-sm">梅军军专属版 | 目标：斩获 Offer</p>
                        
                        <div class="mt-6 flex justify-between text-center">
                            <div>
                                <div class="text-2xl font-bold">{{ totalDone }}</div>
                                <div class="text-xs opacity-75">已刷题数</div>
                            </div>
                            <div>
                                <div class="text-2xl font-bold">{{ correctRate }}%</div>
                                <div class="text-xs opacity-75">正确率</div>
                            </div>
                            <div>
                                <div class="text-2xl font-bold">{{ totalDays }}</div>
                                <div class="text-xs opacity-75">坚持天数</div>
                            </div>
                        </div>
                    </div>

                    <div class="flex-1 p-4 overflow-y-auto">
                        <div class="grid grid-cols-2 gap-4">
                            <button @click="nav('modules')" class="bg-white p-4 rounded-xl shadow-sm hover:shadow-md transition active:scale-95 flex flex-col items-center justify-center h-32">
                                <div class="w-12 h-12 rounded-full bg-blue-100 text-blue-600 flex items-center justify-center mb-2 text-xl">
                                    <i class="fas fa-layer-group"></i>
                                </div>
                                <span class="font-bold text-gray-800">专项练习</span>
                            </button>
                            
                            <button @click="startExam" class="bg-white p-4 rounded-xl shadow-sm hover:shadow-md transition active:scale-95 flex flex-col items-center justify-center h-32">
                                <div class="w-12 h-12 rounded-full bg-purple-100 text-purple-600 flex items-center justify-center mb-2 text-xl">
                                    <i class="fas fa-clock"></i>
                                </div>
                                <span class="font-bold text-gray-800">模拟考试</span>
                            </button>

                            <button @click="nav('errors')" class="bg-white p-4 rounded-xl shadow-sm hover:shadow-md transition active:scale-95 flex flex-col items-center justify-center h-32">
                                <div class="w-12 h-12 rounded-full bg-red-100 text-red-600 flex items-center justify-center mb-2 text-xl">
                                    <i class="fas fa-times-circle"></i>
                                </div>
                                <span class="font-bold text-gray-800">错题本</span>
                                <span class="text-xs text-gray-400 mt-1">{{ wrongCount }} 题待复习</span>
                            </button>

                            <button @click="nav('favorites')" class="bg-white p-4 rounded-xl shadow-sm hover:shadow-md transition active:scale-95 flex flex-col items-center justify-center h-32">
                                <div class="w-12 h-12 rounded-full bg-yellow-100 text-yellow-600 flex items-center justify-center mb-2 text-xl">
                                    <i class="fas fa-star"></i>
                                </div>
                                <span class="font-bold text-gray-800">收藏夹</span>
                            </button>

                             <button @click="nav('cards')" class="bg-white p-4 rounded-xl shadow-sm hover:shadow-md transition active:scale-95 flex flex-col items-center justify-center h-32 col-span-2">
                                <div class="w-12 h-12 rounded-full bg-green-100 text-green-600 flex items-center justify-center mb-2 text-xl">
                                    <i class="fas fa-brain"></i>
                                </div>
                                <span class="font-bold text-gray-800">记忆卡片模式</span>
                                <span class="text-xs text-gray-400 mt-1">手写代码 & 场景题专用</span>
                            </button>
                        </div>
                    </div>
                </div>
            `,
            setup() {
                const totalDone = computed(() => store.progress.completedIds.length + store.progress.wrongIds.length);
                const wrongCount = computed(() => store.progress.wrongIds.length);
                // 简单计算正确率
                const correctRate = computed(() => {
                    const total = totalDone.value;
                    if (total === 0) return 0;
                    return Math.round((store.progress.completedIds.length / total) * 100);
                });
                const totalDays = ref(1); // 暂时写死

                const nav = (view) => {
                    store.view = view;
                };

                const startExam = () => {
                    // 随机抽取 20 题
                    const shuffled = [...QUESTION_BANK].sort(() => 0.5 - Math.random());
                    const selected = shuffled.slice(0, 20);
                    
                    if (selected.length === 0) {
                        alert('题库为空，无法开始考试');
                        return;
                    }

                    store.currentQuestions = selected;
                    store.currentIndex = 0;
                    store.userAnswers = {};
                    store.examMode = true;
                    store.view = 'quiz';
                };

                return { totalDone, wrongCount, correctRate, totalDays, nav, startExam };
            }
        };

        // 4.2 模块选择组件
        const ModuleListView = {
            template: `
                <div class="h-full flex flex-col bg-gray-50">
                    <div class="bg-white p-4 shadow-sm flex items-center">
                        <button @click="back" class="w-8 h-8 flex items-center justify-center text-gray-600">
                            <i class="fas fa-arrow-left"></i>
                        </button>
                        <h2 class="text-lg font-bold ml-2">选择练习模块</h2>
                    </div>
                    
                    <div class="flex-1 overflow-y-auto p-4 space-y-3">
                        <div v-for="mod in modules" :key="mod" @click="selectModule(mod)" 
                             class="bg-white p-4 rounded-xl shadow-sm hover:shadow-md transition active:bg-gray-50 cursor-pointer border-l-4 border-blue-500 flex justify-between items-center">
                            <div>
                                <div class="font-bold text-gray-800">{{ mod }}</div>
                                <div class="text-xs text-gray-400 mt-1">共 {{ getCount(mod) }} 题</div>
                            </div>
                            <div class="flex items-center text-blue-600">
                                <span class="text-sm font-medium mr-2">去练习</span>
                                <i class="fas fa-chevron-right text-xs"></i>
                            </div>
                        </div>
                    </div>
                </div>
            `,
            setup() {
                const modules = MODULES;
                const getCount = (mod) => QUESTION_BANK.filter(q => q.module === mod).length;
                
                const back = () => store.view = 'home';
                
                const selectModule = (mod) => {
                    store.selectedModule = mod;
                    
                    let questions = [];
                    // 记忆卡片模式只筛选 card 类型的题目
                    if (store.view === 'cards') {
                         questions = QUESTION_BANK.filter(q => q.module === mod && q.type === 'card');
                         // 如果该模块没有卡片，提示用户
                         if (questions.length === 0) {
                             alert('该模块暂无记忆卡片，请选择其他模块（如手写代码/场景题）');
                             return;
                         }
                    } else {
                        // 普通模式筛选非 card 题目
                        questions = QUESTION_BANK.filter(q => q.module === mod && q.type !== 'card');
                         if (questions.length === 0) {
                             alert('该模块暂无练习题');
                             return;
                         }
                    }

                    store.currentQuestions = questions;
                    store.currentIndex = 0;
                    store.userAnswers = {};
                    store.examMode = false;
                    store.view = 'quiz';
                };

                return { modules, back, selectModule, getCount };
            }
        };

        // 4.3 答题界面组件 (核心)
        const QuizView = {
            template: `
                <div class="h-full flex flex-col bg-gray-50">
                    <!-- 顶部导航 -->
                    <div class="bg-white p-4 shadow-sm flex items-center justify-between z-10">
                        <button @click="back" class="w-8 h-8 flex items-center justify-center text-gray-600">
                            <i class="fas fa-arrow-left"></i>
                        </button>
                        <h2 class="text-base font-bold truncate mx-2 max-w-[200px]">{{ title }}</h2>
                        <div class="text-sm font-medium text-blue-600">{{ currentIndex + 1 }}/{{ total }}</div>
                    </div>

                    <!-- 答题区域 -->
                    <div class="flex-1 overflow-y-auto p-4 pb-24">
                        <!-- 题目卡片 -->
                        <div class="bg-white p-6 rounded-2xl shadow-sm mb-6">
                            <div class="flex items-center mb-3">
                                <span class="px-2 py-1 bg-blue-100 text-blue-600 text-xs rounded-md font-bold mr-2">
                                    {{ typeLabel }}
                                </span>
                                <button @click="toggleFavorite" class="ml-auto text-xl transition active:scale-125" :class="isFavorite ? 'text-yellow-400' : 'text-gray-300'">
                                    <i class="fas fa-star"></i>
                                </button>
                            </div>
                            <div class="text-lg font-medium leading-relaxed text-gray-800">
                                {{ currentQ.question }}
                            </div>
                        </div>

                        <!-- 选项列表 (选择题/判断题) -->
                        <div v-if="currentQ.type !== 'card'" class="space-y-3">
                            <button v-for="(opt, idx) in options" :key="idx" 
                                @click="selectOption(idx)"
                                :disabled="hasAnswered && !store.examMode"
                                class="w-full text-left p-4 rounded-xl border-2 transition relative overflow-hidden"
                                :class="getOptionClass(idx)">
                                
                                <div class="flex items-start">
                                    <div class="w-6 h-6 rounded-full border-2 flex items-center justify-center mr-3 flex-shrink-0 mt-0.5"
                                         :class="getRadioClass(idx)">
                                        <span v-if="getOptionIcon(idx)" class="text-xs">
                                            <i :class="getOptionIcon(idx)"></i>
                                        </span>
                                        <span v-else class="text-xs font-bold text-gray-400">{{ getOptionLabel(idx) }}</span>
                                    </div>
                                    <span class="text-base">{{ opt }}</span>
                                </div>
                            </button>
                        </div>

                        <!-- 记忆卡片 (Card) -->
                        <div v-else class="h-64 flip-card cursor-pointer" :class="{ 'flipped': cardFlipped }" @click="cardFlipped = !cardFlipped">
                            <div class="flip-card-inner">
                                <div class="flip-card-front">
                                    <div class="text-gray-400 text-sm mb-4">点击翻转查看答案</div>
                                    <i class="fas fa-touch-app text-3xl text-blue-200"></i>
                                </div>
                                <div class="flip-card-back text-left items-start overflow-y-auto">
                                    <div class="w-full">
                                        <div class="font-bold text-blue-600 mb-2">参考答案：</div>
                                        <div class="whitespace-pre-wrap text-sm leading-relaxed">{{ currentQ.answer }}</div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- 解析区域 -->
                        <div v-if="(hasAnswered || (currentQ.type === 'card' && cardFlipped)) && !store.examMode" 
                             class="mt-6 p-4 bg-blue-50 rounded-xl border border-blue-100 animate-fade-in">
                            <div class="flex items-center text-blue-800 font-bold mb-2">
                                <i class="fas fa-lightbulb mr-2 text-yellow-500"></i>
                                答案解析
                            </div>
                            <div class="text-sm text-gray-700 leading-relaxed whitespace-pre-wrap">
                                {{ currentQ.analysis }}
                            </div>
                        </div>
                    </div>

                    <!-- 底部操作栏 -->
                    <div class="fixed bottom-0 left-0 right-0 bg-white border-t p-4 flex items-center justify-between max-w-md mx-auto z-20">
                        <button @click="prev" :disabled="currentIndex === 0" class="px-4 py-2 text-gray-600 disabled:opacity-30">
                            <i class="fas fa-chevron-left mr-1"></i> 上一题
                        </button>

                        <!-- 模拟考试提交按钮 -->
                        <div v-if="store.examMode" class="flex-1 text-center">
                             <button @click="submitExam" class="px-6 py-2 bg-blue-600 text-white rounded-full shadow-lg font-bold text-sm active:scale-95 transition">
                                交卷
                            </button>
                        </div>

                        <!-- 记忆卡片操作按钮 -->
                        <div v-else-if="currentQ.type === 'card'" class="flex space-x-4">
                            <button @click="markCard(false)" class="w-12 h-12 rounded-full bg-red-100 text-red-500 flex items-center justify-center text-xl shadow-sm active:scale-90 transition">
                                <i class="fas fa-times"></i>
                            </button>
                            <button @click="markCard(true)" class="w-12 h-12 rounded-full bg-green-100 text-green-500 flex items-center justify-center text-xl shadow-sm active:scale-90 transition">
                                <i class="fas fa-check"></i>
                            </button>
                        </div>

                        <button @click="next" :disabled="currentIndex === total - 1" class="px-4 py-2 text-blue-600 font-bold disabled:opacity-30">
                            下一题 <i class="fas fa-chevron-right ml-1"></i>
                        </button>
                    </div>
                </div>
            `,
            setup() {
                const title = computed(() => store.examMode ? '模拟考试中...' : store.selectedModule);
                const currentQ = computed(() => store.currentQuestions[store.currentIndex] || {});
                const total = computed(() => store.currentQuestions.length);
                const currentIndex = computed(() => store.currentIndex);
                
                // 记忆卡片状态
                const cardFlipped = ref(false);
                // 监听题目切换，重置翻转状态
                watch(currentIndex, () => {
                    cardFlipped.value = false;
                });

                // 选项处理
                const options = computed(() => {
                    if (currentQ.value.type === 'judge') return ['正确', '错误'];
                    return currentQ.value.options || [];
                });

                const typeLabel = computed(() => {
                    const map = { choice: '选择题', judge: '判断题', card: '记忆卡' };
                    return map[currentQ.value.type] || '题目';
                });

                // 答题状态
                const hasAnswered = computed(() => {
                    return store.userAnswers[currentQ.value.id] !== undefined;
                });

                const isCorrect = computed(() => {
                    if (!hasAnswered.value) return false;
                    const userAns = store.userAnswers[currentQ.value.id];
                    // 判断题处理
                    if (currentQ.value.type === 'judge') {
                        // 选项0是正确(true), 1是错误(false)
                        const val = userAns === 0; 
                        return val === currentQ.value.answer;
                    }
                    return userAns === currentQ.value.answer;
                });

                // 收藏逻辑
                const isFavorite = computed(() => store.progress.favoriteIds.includes(currentQ.value.id));
                const toggleFavorite = () => {
                    const id = currentQ.value.id;
                    if (isFavorite.value) {
                        store.progress.favoriteIds = store.progress.favoriteIds.filter(fid => fid !== id);
                    } else {
                        store.progress.favoriteIds.push(id);
                    }
                    saveProgress();
                };

                // 样式辅助
                const getOptionLabel = (idx) => String.fromCharCode(65 + idx); // A, B, C, D
                
                const getOptionClass = (idx) => {
                    // 未答题/考试模式：默认样式
                    if (!hasAnswered.value || store.examMode) {
                        // 选中态
                        if (store.userAnswers[currentQ.value.id] === idx) {
                            return 'border-blue-500 bg-blue-50 text-blue-700';
                        }
                        return 'border-gray-200 text-gray-700 hover:bg-gray-50';
                    }

                    // 已答题且非考试模式：显示对错
                    const correctAns = currentQ.value.type === 'judge' 
                        ? (currentQ.value.answer ? 0 : 1) 
                        : currentQ.value.answer;

                    // 1. 如果是正确答案 -> 绿色
                    if (idx === correctAns) {
                        return 'border-green-500 bg-green-50 text-green-700';
                    }
                    // 2. 如果用户选了这个且选错了 -> 红色
                    if (store.userAnswers[currentQ.value.id] === idx) {
                        return 'border-red-500 bg-red-50 text-red-700 shake-animation'; // 添加震动
                    }
                    // 3. 其他 -> 变淡
                    return 'border-gray-100 text-gray-400 opacity-60';
                };

                const getRadioClass = (idx) => {
                     // 逻辑同上，仅处理圆圈样式
                     if (!hasAnswered.value || store.examMode) {
                        if (store.userAnswers[currentQ.value.id] === idx) return 'border-blue-500 bg-blue-500 text-white';
                        return 'border-gray-300';
                     }
                     const correctAns = currentQ.value.type === 'judge' ? (currentQ.value.answer ? 0 : 1) : currentQ.value.answer;
                     if (idx === correctAns) return 'border-green-500 bg-green-500 text-white border-transparent';
                     if (store.userAnswers[currentQ.value.id] === idx) return 'border-red-500 bg-red-500 text-white border-transparent';
                     return 'border-gray-200';
                };

                const getOptionIcon = (idx) => {
                    if (!hasAnswered.value || store.examMode) return null;
                    const correctAns = currentQ.value.type === 'judge' ? (currentQ.value.answer ? 0 : 1) : currentQ.value.answer;
                    if (idx === correctAns) return 'fas fa-check';
                    if (store.userAnswers[currentQ.value.id] === idx) return 'fas fa-times';
                    return null;
                };

                // 交互逻辑
                const selectOption = (idx) => {
                    if (hasAnswered.value && !store.examMode) return;
                    
                    // 记录答案
                    store.userAnswers[currentQ.value.id] = idx;

                    // 非考试模式，立即结算进度
                    if (!store.examMode) {
                        const isRight = (currentQ.value.type === 'judge' ? (currentQ.value.answer ? 0 : 1) : currentQ.value.answer) === idx;
                        updateProgress(currentQ.value.id, isRight);
                    }
                };

                const markCard = (known) => {
                    updateProgress(currentQ.value.id, known);
                    // 自动跳下一题
                    setTimeout(() => {
                        if (currentIndex.value < total.value - 1) next();
                    }, 300);
                };

                const updateProgress = (qid, isSuccess) => {
                    // 移除旧状态
                    store.progress.completedIds = store.progress.completedIds.filter(id => id !== qid);
                    store.progress.wrongIds = store.progress.wrongIds.filter(id => id !== qid);

                    if (isSuccess) {
                        store.progress.completedIds.push(qid);
                    } else {
                        store.progress.wrongIds.push(qid);
                    }
                    saveProgress();
                };

                const next = () => {
                    if (currentIndex.value < total.value - 1) store.currentIndex++;
                };

                const prev = () => {
                    if (currentIndex.value > 0) store.currentIndex--;
                };

                const back = () => {
                    if (confirm('确定退出练习吗？')) {
                        store.view = 'modules';
                    }
                };

                const submitExam = () => {
                    if (confirm('确定交卷吗？')) {
                        store.view = 'result';
                        // 将模拟考试的错题加入错题本
                        store.currentQuestions.forEach(q => {
                            const userAns = store.userAnswers[q.id];
                            const correctAns = q.type === 'judge' ? (q.answer ? 0 : 1) : q.answer;
                            if (userAns !== correctAns) {
                                if (!store.progress.wrongIds.includes(q.id)) {
                                    store.progress.wrongIds.push(q.id);
                                }
                            }
                        });
                        saveProgress();
                    }
                };

                return { 
                    store, currentQ, currentIndex, total, title, options, typeLabel,
                    cardFlipped, hasAnswered, isFavorite, toggleFavorite,
                    selectOption, getOptionClass, getRadioClass, getOptionIcon, getOptionLabel,
                    next, prev, back, markCard, submitExam
                };
            }
        };

        // 4.4 模拟考试结果组件
        const ExamResultView = {
            template: `
                <div class="h-full flex flex-col bg-gray-50">
                     <div class="bg-white p-6 shadow-sm flex flex-col items-center">
                        <div class="text-xl font-bold mb-4">考试结束</div>
                        <div class="w-32 h-32 rounded-full border-8 flex items-center justify-center text-4xl font-bold mb-4"
                             :class="score >= 60 ? 'border-green-500 text-green-600' : 'border-red-500 text-red-600'">
                             {{ score }}
                        </div>
                        <div class="text-sm text-gray-500">满分 100 分</div>
                     </div>

                     <div class="flex-1 overflow-y-auto p-4">
                        <h3 class="font-bold text-gray-700 mb-3">答题卡</h3>
                        <div class="grid grid-cols-5 gap-3">
                            <button v-for="(q, idx) in questions" :key="q.id" 
                                class="w-10 h-10 rounded-full flex items-center justify-center font-bold text-sm"
                                :class="getResultClass(q)"
                                @click="viewAnalysis(idx)">
                                {{ idx + 1 }}
                            </button>
                        </div>
                     </div>

                     <div class="p-4 bg-white border-t">
                        <button @click="back" class="w-full py-3 bg-blue-600 text-white rounded-xl font-bold shadow-lg hover:bg-blue-700 active:scale-95 transition">
                            返回首页
                        </button>
                     </div>
                </div>
            `,
            setup() {
                const questions = store.currentQuestions;
                
                // 计算分数 (每题5分，共20题)
                const score = computed(() => {
                    let correctCount = 0;
                    questions.forEach(q => {
                        const userAns = store.userAnswers[q.id];
                        const correctAns = q.type === 'judge' ? (q.answer ? 0 : 1) : q.answer;
                        if (userAns === correctAns) correctCount++;
                    });
                    return Math.round((correctCount / questions.length) * 100);
                });

                const getResultClass = (q) => {
                    const userAns = store.userAnswers[q.id];
                    // 未答
                    if (userAns === undefined) return 'bg-gray-200 text-gray-500';
                    
                    const correctAns = q.type === 'judge' ? (q.answer ? 0 : 1) : q.answer;
                    return userAns === correctAns ? 'bg-green-100 text-green-600' : 'bg-red-100 text-red-600';
                };

                const viewAnalysis = (idx) => {
                    // 进入错题查看模式 (复用 QuizView，但可能需要调整状态，这里简单处理为直接跳转)
                    // 为了简化，这里暂不支持点击跳转查看解析，仅展示概览
                    // 实际应用中可扩展为 Review Mode
                    alert('点击题号查看解析功能开发中，请关注后续版本');
                };

                const back = () => store.view = 'home';

                return { score, questions, getResultClass, viewAnalysis, back };
            }
        };

        // 4.5 列表视图 (错题本/收藏夹通用)
        const QuestionListView = {
            template: `
                 <div class="h-full flex flex-col bg-gray-50">
                    <div class="bg-white p-4 shadow-sm flex items-center">
                        <button @click="back" class="w-8 h-8 flex items-center justify-center text-gray-600">
                            <i class="fas fa-arrow-left"></i>
                        </button>
                        <h2 class="text-lg font-bold ml-2">{{ title }}</h2>
                    </div>

                    <div v-if="list.length === 0" class="flex-1 flex flex-col items-center justify-center text-gray-400">
                        <i class="fas fa-folder-open text-4xl mb-4"></i>
                        <p>暂无相关题目</p>
                    </div>

                    <div v-else class="flex-1 overflow-y-auto p-4 space-y-3">
                         <div v-for="(q, idx) in list" :key="q.id" 
                              @click="startPractice(idx)"
                              class="bg-white p-4 rounded-xl shadow-sm active:bg-gray-50 cursor-pointer">
                            <div class="flex justify-between items-start mb-2">
                                <span class="px-2 py-0.5 bg-blue-50 text-blue-600 text-xs rounded">{{ q.module }}</span>
                                <button @click.stop="removeItem(q.id)" class="text-gray-400 hover:text-red-500 p-1">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                            <div class="font-medium text-gray-800 line-clamp-2">{{ q.question }}</div>
                         </div>
                    </div>
                 </div>
            `,
            setup() {
                const isErrorView = computed(() => store.view === 'errors');
                const title = computed(() => isErrorView.value ? '错题本' : '收藏夹');
                
                const list = computed(() => {
                    const ids = isErrorView.value ? store.progress.wrongIds : store.progress.favoriteIds;
                    // 按 ID 查找题目，并反转顺序(新题在前)
                    return ids.map(id => QUESTION_BANK.find(q => q.id === id)).filter(Boolean).reverse();
                });

                const back = () => store.view = 'home';

                const startPractice = (startIdx) => {
                    store.currentQuestions = list.value;
                    store.currentIndex = startIdx;
                    store.userAnswers = {};
                    store.examMode = false;
                    store.view = 'quiz';
                };

                const removeItem = (id) => {
                    if (isErrorView.value) {
                        store.progress.wrongIds = store.progress.wrongIds.filter(wid => wid !== id);
                    } else {
                        store.progress.favoriteIds = store.progress.favoriteIds.filter(fid => fid !== id);
                    }
                    saveProgress();
                };

                return { title, list, back, startPractice, removeItem };
            }
        };
        
        // 4.6 模拟考试控制逻辑
        // 修改 HomeView 中的 startExam
        
        // 占位组件
        const PlaceholderView = {
            template: `<div class="p-8 text-center"><h2 class="text-xl">功能开发中...</h2><button @click="back" class="mt-4 px-4 py-2 bg-blue-600 text-white rounded">返回</button></div>`,
            setup() { return { back: () => store.view = 'home' } }
        };

        const app = createApp({
            setup() {
                onMounted(() => {
                    loadProgress();
                });

                const currentViewComponent = computed(() => {
                    switch (store.view) {
                        case 'home': return HomeView;
                        case 'modules': return ModuleListView;
                        case 'quiz': return QuizView;
                        case 'result': return ExamResultView;
                        case 'cards': return ModuleListView; // 记忆卡片模式复用模块选择逻辑，但需过滤
                        case 'errors': return QuestionListView;
                        case 'favorites': return QuestionListView;
                        default: return HomeView;
                    }
                });

                return { currentViewComponent };
            }
        });

        app.mount('#app');
    </script>

</body>
</html>
